[{"id":0,"href":"/VisualComputing/docs/workshops/optical_illusions/","title":"Optical Illusions","section":"Docs","content":" Ilusiones √ìpticas üëÄ üß† # Las ilusiones √≥pticas, son im√°genes que el ojo humano percibe como real y que en realidad no existe.\nLas ilusiones √≥pticas son producto de que los ojos envias informaci√≥n a nuestro cerebro que nos hace creer que podemos ver algo que realmente no existe.\nExisten diferentes tipos de ilusiones √≥pticas. Ya sean las psicol√≥gicas, las ambiguas, distorsionadores y las parad√≥jicas, todas juegan con lo que percibimos como realidad y nos hace cuestionar si todo lo que vemos nuesto cerebro lo percibe como real y tal vez no exista.\nIlusiones ambiguas: Son im√°genes que se pueden ver en m√°s de una forma. Un ejemplo de ello es la imagen de dos personas de perfil que puede interpretarse como una copa de beber.\nIlusiones parad√≥jicas: Son im√°genes que muestran objetos que no pueden existir debido a que rompen las leyes de la f√≠sica. Este tipo de ilusiones se ven mayoritariamente en las obras de arte.\nIlusiones psicol√≥gicas: Causadas por el orden psicol√≥gico de cada mente y lo que ven sus ojos.\nIlusiones de distorsi√≥n: Son im√°genes que usan t√©cnicas de dise√±o para hacer objetos que poseen el mismo tama√±o, verse distorsionados.\nDato curioso ‚ö° # La palabra ilusi√≥n viene del lat√≠n illudere que significa burlarse. Algunos ejemplos de ilusiones √≥pticas # Adaptaci√≥n del contorno - Stuart Anstis En esta ilusi√≥n √≥ptica trata sobre la adaptaci√≥n al contraste que hace que al mantenerse las ruedas de la bicicleta parpadeando de blanco a negro, la funci√≥n de transferencia de contraste se desplace.\nEsta funci√≥n de transferencia de contraste hace referencia a c√≥mo las anomalias en un microscopio electr√≥nico de transmisi√≥n (TEM) modifican el resultado de la imagen vista desde all√≠ y por lo tanto los pasos de la luminancia del contorno de las ruedas hace que haya un subumbral (proceso en el que se usan peque√±os impulsos el√©ctricos para estimular los m√∫sculos d√©biles).\nDebido a que al no poder observar la percepci√≥n de los pasos de cambio de color de las ruedas y al generar e subumbra, el ojo perder√° la vista de toda el √°rea. La ganancia de contraste junto con una constante de tiempo hace que se pueda percibir las ruedas existentes de la b√≠cicleta.\n¬øC√≥mo funciona? # Para evidenciar la ilusi√≥n √≥ptica se debe mantener el click presionado, all√≠ entonces empezar√° a funcionar la ilusi√≥n.\nSe recomienda presionar el mayor tiempo posible para experimentar una mejor sensaci√≥n\nC√≥digo # let tamanioCanvas = 500; var angulo = 0; var velocidad = 0.09; function setup() { createCanvas(tamanioCanvas*1.3, tamanioCanvas); angleMode(DEGREES); } function draw() { let ms = millis(); let cloudx = 100; let cloudy = 100; let blue = 189; background(119,119,119); //Nubes makeCloud(cloudx, cloudy-70); makeCloud(cloudx + 100, cloudy + 30) makeCloud(cloudx + 300, cloudy - 70) makeCloud(cloudx + 380, cloudy + 10) cloudx+=0.1; //Pasto //Ruedas fill(132,132,132) noStroke() circle(200,350,130); circle(440,353,130); strokeWeight(11); stroke(\u0026#39;#7F7FCC\u0026#39;) line(200, 350, 250, 200); //manubrio line(250,200, 280, 200); //Marco line(240,245,360,350); // \\ line(400,230,360,340); // / line(360,350,440,353); // _ line(440,353,390,255); line(240,245,390,245); //sill√≠n line(390,230,410,230); if (mouseIsPressed === true) { //ruedas alumbrantes if(ms%1.5 === 0){ noFill(); stroke(\u0026#39;black\u0026#39;); strokeWeight(8); circle(200,350,130); circle(440,353,130); }else{ noFill(); stroke(\u0026#39;white\u0026#39;) strokeWeight(8) circle(200,350,130); circle(440,353,130); } //+ translate(320, 300); strokeWeight(3) stroke(\u0026#39;#00ff00\u0026#39;); rotate(angulo); line(0,0,5,5); line(0,0,-5,5); line(0,0,5,-5); line(0,0,-5,-5); angulo++; } } function makeCloud(cloudx, cloudy) { fill(250) noStroke(); ellipse(cloudx, cloudy, 70, 50); ellipse(cloudx + 10, cloudy + 10, 70, 50); ellipse(cloudx - 20, cloudy + 10, 70, 50); } class Mas{ constructor(x_1, y_1, x_2, y_2) { this.x_1 = x_1; this.y_1 = y_1; this.x_2 = x_2; this.y_2 = y_2; } display(){ strokeWeight(3) stroke(\u0026#39;#00ff00\u0026#39;); rotate(0) line(this.x_1,this.y_1,this.x_2,this.y_2); rotate(0) line(this.x_1+5,this.y_1-5,this.x_2-5,this.y_2+5); angulo++; } } La ilusi√≥n confeti üéâ üéâ üéâ Esta ilusi√≥n muestra como varios elementos que poseen un mismo color, al estar expuestos a diferentes franjas de determinados colores se pueden percibir como colores diferentes.\nLa base de esta ilusi√≥n √≥ptica es ver como a partir de la aparici√≥n de ciertos colores entro de un elemento, se pueden generar cambios en el color. Es importante destacar que esta ilusi√≥n √≥ptica no toma en cuenta la luminacia en ning√∫n instante.\nIlusiones de asimilaci√≥n de color üî¥ üü¢ üü° üîµ Estas ilusiones permiten ver c√≥mo se puede cambiar el color de fondode ciertos objetos cuando introducimos formas de colores dentro de ellos, como por ejemplo las rayas, c√≠rculos conc√©ntricos, etc.\nAun independientemente del tipo de forma que se use para que se sobreponga a los objetos de igual color, el efecto ser√° el mismo debido a que el cerebro desea llenar los espacios vac√≠os de entre las rayas y esto lo hace teniendo en cuenta los colores que tenga a su alrededor. Es importante destacar que estos colores deben poseer una luminancia mayor a la del color que poseen las formas, de esta manera se garantiza que el cerebro capte mejor las rayas m√°s sobresalientes.\nDato curioso ‚ö° # El color es una de las cosas m√°s subjetivas que existen. Muchas personas no poseen la capacidad de diferencias entre tonos de colores en incluso colores. ¬°Pru√©balo t√∫ mismo! üé© ü™Ñ # Para quitar las rayas de colores y poder evidenciar el efecto de esta ilusi√≥n optica se debe mantener presionado el mouse.\nC√≥digo # let ancho = 0.4; let alturaMalla = 0.5; let distanciaEntreBarras = 400; let numeroBarras = 4; let tamanio = 500 let tamanioBarrasCuadrado = 10; let tamanioCuadrado = 45 function setup() { createCanvas(tamanio*1.4, tamanio); let franjas = tamanio/(ancho*numeroBarras) cuadrado1 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,100,60, \u0026#34;red\u0026#34;); cuadrado2 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,100,270, \u0026#34;green\u0026#34;); cuadrado3 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,100,460, \u0026#34;red\u0026#34;); cuadrado4 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,100,700); cuadrado5 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,300,170); cuadrado6 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,300,370); cuadrado7 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,300,570); cuadrado8 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,500,60); cuadrado9 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,500,260); cuadrado10 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,500,460); cuadrado11 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,500,710); cuadrado12 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,700,170); cuadrado13 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,700,370); cuadrado14 = new Cuadrado(tamanioCuadrado,tamanioBarrasCuadrado,700,560); malla = new Malla(10,0,alturaMalla,0,distanciaEntreBarras,numeroBarras, franjas); } function draw() { background(238, 75, 43); let c = color(250,219,172); fill(c); noStroke(); if (mouseIsPressed === false) { malla.display(); } cuadrado1.display(); cuadrado2.display(); cuadrado3.display(); cuadrado4.display(); cuadrado5.display(); cuadrado6.display(); cuadrado7.display(); cuadrado8.display(); cuadrado9.display(); cuadrado10.display(); cuadrado11.display(); cuadrado12.display(); cuadrado13.display(); cuadrado14.display(); } // clase Malla class Malla { constructor(iw, ixp, ih, iyp, id, it, f) { this.w = iw; // ancho de una barra this.xpos = ixp; // posici√≥n x del rect√°ngulo this.h = ih; // altura del rect√°ngulo this.ypos = iyp; // posici√≥n y del rect√°ngulo this.d = id; // distancia de una barra this.t = it; // n√∫mero de barras this.f = f; //Franjas de colores en la imagen } display() { let verde = color(105,229,174) let rojo = color(238, 75, 43) for (let i = 0; i \u0026lt; tamanio; i++) { fill(verde); rect(0 , this.ypos + i * (2*this.w) , tamanio*1.5, this.w); } } } // clase cuadrado con lineas verdes class Cuadrado{ constructor(lado, anchoLineas, x , y ,color) { this.lado = lado this.w = anchoLineas this.x = x this.y = y this.color = color } display() { let lineas = this.lado/this.w fill(185,182,233) rect(this.x, this.y, 2*this.lado, 2*this.lado); let rayas = new Rayas(this.lado, this.w, this.x, this.y,this.color); if (mouseIsPressed === false) { rayas.display(); } } } // clase cuadrado con lineas rojas class CuadradoRed { constructor(lado, anchoLineas, x , y ) { this.lado = lado this.w = anchoLineas this.x = x this.y = y } display() { let lineas = this.lado/this.w fill(185,182,233) rect(this.x, this.y, 2*this.lado, 2*this.lado); for(let i = 0; i\u0026lt; lineas-1; i++){ fill(238, 75, 43); rect(this.x, this.y + i * (2*this.w)+10, this.lado * 2, this.w) } } } class Rayas{ constructor(lado, anchoLineas, x , y , color) { this.lado = lado this.w = anchoLineas this.x = x this.y = y this.color = color } display() { let lineas = this.lado/this.w for(let i = 0; i\u0026lt; lineas-1; i++){ if(this.color === \u0026#39;red\u0026#39;){ fill(238, 75, 43); }else{ fill(105,229,174); } rect(this.x, this.y + i * (2*this.w)+10, this.lado * 2, this.w) } } } Tip üì£ # ¬°Al√©jate un poco para poder apreciar mejor el efecto de la ilusi√≥n! Animaci√≥n y estereograf√≠a de rejilla de barrera üíÉ üé• Esta ilusi√≥n √≥ptica muestra como a trav√©s de una rejilla y partes de un fotograma, se puede recrear un movimiento.\nLa animaci√≥n y la estereograf√≠a de rejilla naci√≥ en 1980 y fue utiliado ampliamente en el sector del cine ya que el m√©todo de pryecci√≥n de las p√©liculas se basaba en una rejilla que se mantina est√°rica y una colecci√≥n de fotos con animaci√≥n de cuadr√≠cula y de esta manera se lograba obtener toda una escena.\nEsta manera de obtener movimiento se basa en lograr enga√±ar al cerebro y persuadirlo a ver lo que se quiere ya que el uso de estas franjas hacer que esto puendan descubrir figuras en patrones de datos asombrosamente escasos, si solo se mueven coherentemente. Las distancia entre rejas debe lograr solapar con las lineas de la imagen ajustada.\n¬øC√≥mo se crea una animaci√≥n de cuadr√≠cula? ü§î # Para empezar se debe contar con una secuencia de fotogramas del objeto en movimiento. Se requiere que esta secuencia empiece y termine igual, estas se sobrepondran en determinado momento.\nPosterior a ello cada imagen se deber√° convertir en una silueta sombreada o en su defecto oscura, y por cada una de estas im√°genes se tomar√°n las l√≠neas sombreadas que se deseen. El n√∫mero de lineas no es del todo relevantes, pero re requiere que el ancho y el espaciado de la cuadr√≠cula logren captar las l√≠neas de la imagen en determinado momento para que esta pueda simular el efecto de movimiento. Para mayor efecto de la ilusi√≥n estas im√°genes puedes llevar colores y entre las lineas de las fotos se pueden generar sombreados para evitar el corte de las im√°genes.\nC√≥digo # let ancho = 10; let alturaMalla = 0.4; let distanciaEntreBarras = 1; let numeroBarras = 40; let equivalencia = 770 function setup() { createCanvas(700, 700); malla = new Malla(ancho,0,alturaMalla,0,distanciaEntreBarras,numeroBarras); } function draw() { background(255); //Creaci√≥n de la malla malla.display(); malla.move(mouseX, mouseY); strokeWeight(2); //Se dibuja la m√°quina rect(410,150,100,100); rect(420,250,80,20); rect(420,270,1,70) for (let i = 425; i\u0026lt; 495; i+=10){ rect(i,270,7,7); } for (let i = 425; i\u0026lt; 495; i+=10){ rect(i,278,5,30); } for (let i = 485; i\u0026gt;= 425; i-=10){ rect(i,309,3,15); } for (let i = 485; i\u0026gt;= 425; i-=10){ rect(i+2,324,1,15); } rect(495, 270, 5,5); rect(494, 278, 5,30); rect(494, 307, 3,15); rect(497, 324, 1,15); //Se crea malla principal for (let i = 0; i\u0026lt;=500; i+=10){ strokeWeight(4); line(i, 300,i, 370); strokeWeight(2); } //Se crea malla luego de pasar por la maquina for (let i = 480; i\u0026lt;=1000; i+=10){ strokeWeight(5); line(i, 360,i, 370); strokeWeight(1); line(i+3, 358,i+3, 372); line(i+4, 357,i+4, 372); strokeWeight(2); } let x = 0; let y = 300; for(let i = 0; i\u0026lt;= 8; i+=1){ strokeWeight(2); line(x, y+5,x, y+73); line(x-10, y+10,x-10, y+73); line(x+2, y-2,x+2, y+76); line(x-2, y-2,x-2, y+76); line(x-13, y+8,x-13, y+75); line(x-23, y+18,x-23, y+61); line(x-12, y+25,x-12, y+58); line(x-20, y+20,x-20, y+63); line(x-22, y+16,x-22, y+59); line(x+12, y+25,x+12, y+58); line(x+10, y+10,x+10, y+73); line(x+13, y+8,x+13, y+75); line(x+23, y+18,x+23, y+63); line(x+20, y+20,x+20, y+65); line(x+30, y+30,x+30, y+55); x+=60; } strokeWeight(2); } // clase Malla class Malla { constructor(iw, ixp, ih, iyp, id, it) { this.w = iw; // ancho de una barra this.xpos = ixp; // posici√≥n x del rect√°ngulo this.h = ih; // altura del rect√°ngulo this.ypos = iyp; // posici√≥n y del rect√°ngulo this.d = id; // distancia de una barra this.t = it; // n√∫mero de barras } display() { for (let i = 0; i \u0026lt; this.t; i++) { let negro = color(\u0026#39;black\u0026#39;); fill(negro); stroke(255,255,255) rect( this.xpos + i * (this.d + this.w), this.ypos, this.w, height * this.h ); stroke(0,0,0) } } move(posX, posY) { this.ypos = posY; this.xpos = posX; } } Referencias # Constrast transfer function Anstis\u0026rsquo; Contour Adaptation Ilusi√≥n √≥ptica de Munker-White: cuesti√≥n de percepciones The confetti illusion Barrier-grid animation and stereography Barrier-Grid (or Picket-Fence) Animation "},{"id":1,"href":"/VisualComputing/docs/workshops/solar_system/","title":"Solar System","section":"Docs","content":" Sistema solar üåû ü™ê # El sistema solar es un sistema planetario ubicado en la via lactea, una galax√≠a conformada por alrededor de mil millones de estrellas y compuesta por tres brazos en espiral: orion, perseo y centauro.\nNuestro sistema solar se encuentra en el brazo orion y est√° compuesto por nuestra estrella sol y 8 planetas: mercurio, venus, tierra, marte, jupiter, saturno, urano y nepturno.\nCada planeta cuenta con su propia velocidad de traslaci√≥n y rotaci√≥n, donde factores como la cercan√≠a al sol, su masa y sus compuestos hacen que esta se afecte. A su vez la gravedad de cada uno depende de cuan lejos se encuentren de otro objeto.\nLa informaci√≥n acerca de cada planeta en el sistema solar se muestra a continuaci√≥n:\nPlaneta üåé Gravedad ‚è¨ Velocidad üí® Masa üé± Distancia üìè Mercurio 3,7 m/s2 172.404 km/h 3,28 x 10^23 kg 579.000.000 km Venus 8,87 m/s2 126.108 km/h 4,83 x 10^24 kg 108.200.000 km Tierra 9,807 m/s2 107.244 km/h 5,98 x 10^24 kg 149.600.000 km Marte 3,721 m/s2 86.868 km/h 2,28 x 10^23 kg 227.900.000 km Jupiter 24,79 m/s2 47.016 km/h 1,90 x10^27 kg 778.410.000 km Saturno 10,44 m/s2 34.705 km/h 5,98x 10^26 kg 1.427.000.000 km Urano 8,87 m/s2 24.516 km/h 8,67 x10^25 kg 2.870.000.000 km Nepturno 11,15 m/s2 19.548 km/h 1,05 x 10^26 kg 4.496.000.000 km Escalas # Tama√±o Debido a que el sol demuestra ser un astro gigante respecto a los dem√°s planetas del sistema solar, la escala de tama√±o que se di√≥ para el sol fue de 1:10000000, la escala para los planetas se determin√≥ con respecto a un factor proporcional al sol para efectos de que la visualizaci√≥n sea entendible.\nVelocidad La escala de velocidad que se determin√≥ fue 1:100000000 para cada uno de los planetas.\nDistancia La escalas de distancia que se determin√≥ fue de 1:10000000 para cada uno de los planetas\nEl planeta tierra en el sistema solar üåç # ¬øQu√© hace que la vida sea posible en el planeta tierra o por que hasta el momento en otros planetas no se ha encontrado se√±ales de vida?\nLa vida en el planeta tierra es un evento que muestra la perfecci√≥n de la naturaleza, pues la alteraci√≥n de una sola caracter√≠stica pudo cambiar todo el rumbo de la vida.\nDistancia al sol üåû La distancia que el planeta tierra tiene al sol brinda unos n√≠veles de temperatura y de luz √≥ptimos para la vida pues tanto la temperatura como la luz brinda energ√≠a y sustento.\nDimensiones y atm√≥sfera üìè Gracias a las dimensiones del planeta este puede atraer la atm√≥fera para s√≠, si llegase la tierra a tener un poco menos de su masa, la fuerza gravitatoria no ser√≠a capaz de atraer la atmosf√©ra y no ser√≠a posible la vida, pues es esta misma atm√≥sfera es la que es capaz de proteger de radiaciones perjudicilaes mientras brinda elementos necesarios para la vida como el ox√≠geno.\nComponentes qu√≠micos ‚öõ Gracias a los elementos disponibles en la superficie de la tierra y su combinaci√≥n permiten la vida.\nCampo magn√©tico terrestre üß≤ El campo magn√©tico permite proteger a los organismos de la radiaci√≥n solar en la superficie y a los vientos solares.\nSi este campo no existiera con sus respectivas magnitudes la formas de vida cambiar√≠a, por ejemplo:\nLas aves no sabr√≠an hacia donde migrar. Animales se guian por este mismo campo magn√©tico. Fundamental para el crecimiento de las plantas. Agua en estado l√≠quido üí¶ üö§ No es sopresa que el agua sea el elemento fundamental para la vida y es gracias a que el 70% de nuestro planeta posea este compuesto que la vida puede sostenerse, regulando su temperatura, hidratando y otro sin fin de caracter√≠sticas.\nPara la pr√°ctica #2 del curso de computaci√≥n visual se presenta un sistema solar din√°mico implementado mediante p5.js y haciendo uso de los diferentes conceptos de transformaciones vistos en clase.\n!Ponlo a prueba! ‚ö° # La implentaci√≥n puedes hacer uso de:\nSelect para acercarte al planeta que desees. Ub√≠cate en el planeta que desees para obtener informaci√≥n del planeta. Presiona el mouse y mu√©vete para tener una vista 360¬∞. Conceptos de clase # Los conceptos y librer√≠as usadas para la implementaci√≥n del sistema solar se hizo uso de las siguientes t√©cnicas:\nManejo de la c√°mara üì∑ # Para esta escena 3D nos apoyamos en EasyCam, que provee un marco f√°cil para trabajar con la c√°mara en un entorno WEBGL.\nLa interacci√≥n con el usuario a trav√©s del raton se hace de una manera sencilla, en la cual se puede cambiar la rotaci√≥n y la distancia a la cual se ven los objetos en la escena.\nTambi√©n nos provee el manejo de states los cuales nos permitir√°n movernos a cada planeta de una manera sencilla, en la secci√≥n de movimiento de c√°mara se explica m√°s a fondo.\nTexturas üñåÔ∏è # Las texturas son aplicadas principalmente a objetos esfera (que son los planetas) y usamos el modo de textura NORMAL.\nLa fuente de las texturas las puedes encontrar en la secci√≥n de referencias.\nMovimiento de traslaci√≥n de los planetas ü™ê # Primero, configuramos una clase que nos ayuda a dibujar las orbitas y en esas orbitas dibujamos cada esfera correspondiente a un planeta (para mas info. ver la clase Orbit en c√≥digo)\nPara configurar el movimiento de traslaci√≥n de los planetas en sus orbitas usamos la siguiente funci√≥n (tra√≠da desde nuestro codigo para analizarla):\nrotate2(vect, axis, angle) { axis = p5.Vector.normalize(axis); return p5.Vector.add( p5.Vector.mult(vect, cos(angle)), p5.Vector.add( p5.Vector.mult(p5.Vector.cross(axis, vect), sin(angle)), p5.Vector.mult( p5.Vector.mult(axis, p5.Vector.dot(axis, vect)), 1 - cos(angle) ) ) ); } Primero, se debe normalizar el vector axis, luego retornamos el resultado de:\nSumar dos vectores El primer vector es la multiplicaci√≥n de un escalar (cos(angle)) y el vector que recibimos como par√°metro El segundo vector es la multiplicaci√≥n de un escalar (1 - cos(angle)) y otro vector (4) Este vector es la multiplicaci√≥n de un escalar (producto punto p5.Vector.dot(axis, vect)) y el vector axis. Seleccionador de elementos üëÜüèª # Mediante el m√©todo de mousePickin de la librer√≠a TreeGL se activa el cuadro de texto donde se muestra la informaci√≥n acerca del planeta. La informaci√≥n de planeta se consumi√≥ mediante la API https://api.le-systeme-solaire.net/rest.php/bodies?filter%5B%5D=isPlanet%2Ceq%2Ctrue\nMovimiento de c√°mara hacia un elemento üì∏ # Mediante el uso de key frames se realiz√≥ la traslaci√≥n de la c√°mara de un planeta a otro y se realiz√≥ la configuraci√≥n para que la c√°mara contin√∫e mostrando el planeta independiente de su traslaci√≥n.\nEl m√©todo detr√°s de la funci√≥n es la interpolaci√≥n que realiza la librer√≠a para lograr trazar la trayectoria y llegar al objeto.\nEl m√©todo de interpolaci√≥n que se usa es mediante splines y con la t√©cnica de Catmull-Rom donde los puntos de trayectoria resultan m√°s sencillos de calcular y permiten la obtenci√≥n de un movimiento suavizado y garantiza que las tangentes de la curva sean continuas en los segmentos.\nC√≥digo de la implementaci√≥n # A continuaci√≥n se detalla el c√≥digo de la implementaci√≥n\nconst sun_size = 100 const earth_speed = 100 // Code adapted from https://editor.p5js.org/cigno5/sketches/PqB9CEnBp let sun_texture; let mercury_texture; let venus_texture; let stars; let earth_texture; let mars_texture; let jupiter_texture; let saturn_texture; let uranus_texture; let neptune_texture; let planets_font; let saturn_ring_texture; let orbit1; let orbit2; let orbit3; let orbit4; let orbit5; let orbit6; let orbit7; let orbit8; let planetsData; let uranusData; let neptureData; let jupiterData; let marsData; let mercurData; let saturnData; let earthData; let venusData; let newCenter; let followPlanet = \u0026#34;free\u0026#34;; let auto_rotate; let mode; let easycam; let frames = 0; let dotId = 0; let rotating = false; let orbits = []; let dotsData = []; let planetSelector; function preload() { stars = loadImage(\u0026#34;/VisualComputing/sketches/assets/2k_stars_milky_way.jpg\u0026#34;); sun_texture = loadImage(\u0026#34;/VisualComputing/sketches/assets/8k_sun.jpg\u0026#34;); mercury_texture = loadImage( \u0026#34;/VisualComputing/sketches/assets/8k_mercury.jpg\u0026#34; ); venus_texture = loadImage(\u0026#34;/VisualComputing/sketches/assets/4k_venus.jpg\u0026#34;); earth_texture = loadImage( \u0026#34;/VisualComputing/sketches/assets/2k_earth_daymap.jpg\u0026#34; ); mars_texture = loadImage(\u0026#34;/VisualComputing/sketches/assets/8k_mars.jpg\u0026#34;); jupiter_texture = loadImage( \u0026#34;/VisualComputing/sketches/assets/8k_jupiter.jpg\u0026#34; ); saturn_texture = loadImage(\u0026#34;/VisualComputing/sketches/assets/8k_saturn.jpg\u0026#34;); uranus_texture = loadImage(\u0026#34;/VisualComputing/sketches/assets/2k_uranus.jpg\u0026#34;); neptune_texture = loadImage( \u0026#34;/VisualComputing/sketches/assets/2k_neptune.jpg\u0026#34; ); planets_font = loadFont(\u0026#34;/VisualComputing/sketches/assets/Nasa.ttf\u0026#34;) saturn_ring_texture = loadImage(\u0026#34;/VisualComputing/sketches/assets/8k_saturn_ring_alpha.png\u0026#34;) } function setup() { loadJSON(\u0026#34;https://api.le-systeme-solaire.net/rest.php/bodies?filter%5B%5D=isPlanet%2Ceq%2Ctrue\u0026#34;, planets); createCanvas(700, 1000, WEBGL); textureMode(NORMAL); textFont(planets_font); easycam = createEasyCam(); easycam.setState({ distance: 900, center: [0, 0, 0], rotation: [0.5, -0.15, 0.77, 0.3], }); planetSelector = createSelect(); planetSelector.position(20, 20); planetSelector.option(\u0026#34;sun\u0026#34;); planetSelector.option(\u0026#34;mercury\u0026#34;); planetSelector.option(\u0026#34;venus\u0026#34;); planetSelector.option(\u0026#34;earth\u0026#34;); planetSelector.option(\u0026#34;mars\u0026#34;); planetSelector.option(\u0026#34;jupiter\u0026#34;); planetSelector.option(\u0026#34;saturn\u0026#34;); planetSelector.option(\u0026#34;uranus\u0026#34;); planetSelector.option(\u0026#34;neptune\u0026#34;); planetSelector.option(\u0026#34;free\u0026#34;); planetSelector.changed(travelPlanet); console.log(easycam.getState()); orbit1 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 600, 680); orbit1.obj.push(new Dot(0, 0.05, 600, 680, mercury_texture, sun_size*0.18, \u0026#34;mercur\u0026#34;)); orbits.push(orbit1); orbit2 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 900, 980); orbit2.obj.push(new Dot(0, 0.048, 900, 980, venus_texture, sun_size*0.25,\u0026#34;venus\u0026#34;)); orbits.push(orbit2); orbit3 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 1500, 1580); orbit3.obj.push(new Dot(0, 0.075, 1500, 1580, earth_texture, sun_size*0.26, \u0026#34;earth\u0026#34;)); orbits.push(orbit3); orbit4 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 1900, 1980); orbit4.obj.push(new Dot(0, 0.06, 1900, 1980, mars_texture, sun_size*0.20, \u0026#34;mars\u0026#34;)); orbits.push(orbit4); orbit5 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 2700, 2780); orbit5.obj.push(new Dot(0, 0.15, 2700, 2780, jupiter_texture, sun_size*0.65, \u0026#34;jupiter\u0026#34;)); orbits.push(orbit5); orbit6 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 3000, 3080); saturn_ring = new Ring(190, 0, 0.1, 3000, 3080, saturn_ring_texture ); orbit6.obj.push(new Dot(0, 0.13, 3000, 3080, saturn_texture, sun_size*0.63, \u0026#34;saturn\u0026#34;)); orbit6.obj.push(saturn_ring); orbits.push(orbit6); orbit7 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 4000, 4080); orbit7.obj.push(new Dot(0, 0.09, 4000, 4080, uranus_texture, sun_size*0.32, \u0026#34;uranus\u0026#34;)); orbits.push(orbit7); orbit8 = new Orbit(0, 0, 0, 0.5, 0.5, 0.5, 4900, 4980); orbit8.obj.push(new Dot(0, 0.08, 4900, 4980, neptune_texture, sun_size*0.31, \u0026#34;neptune\u0026#34;)); orbits.push(orbit8); } function planets(data){ print(data); planetsData = data } function draw() { //Data planets if (planetsData){ uranusData = { \u0026#34;name\u0026#34;: planetsData.bodies[0].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[0].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[0].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[0].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[0].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[0].moons, } neptureData = { \u0026#34;name\u0026#34;: planetsData.bodies[1].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[1].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[1].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[1].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[1].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[1].moons, } jupiterData = { \u0026#34;name\u0026#34;: planetsData.bodies[2].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[2].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[2].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[2].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[2].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[2].moons, } marsData = { \u0026#34;name\u0026#34;: planetsData.bodies[3].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[3].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[3].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[3].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[3].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[3].moons, } mercurData = { \u0026#34;name\u0026#34;: planetsData.bodies[4].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[4].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[4].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[4].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[4].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[4].moons, } saturnData = { \u0026#34;name\u0026#34;: planetsData.bodies[5].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[5].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[5].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[5].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[5].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[5].moons, } earthData = { \u0026#34;name\u0026#34;: planetsData.bodies[6].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[6].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[6].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[6].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[6].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[6].moons, } venusData = { \u0026#34;name\u0026#34;: planetsData.bodies[7].englishName, \u0026#34;gravity\u0026#34;: planetsData.bodies[7].gravity, \u0026#34;discoveredBy\u0026#34;: planetsData.bodies[7].discoveredBy, \u0026#34;discoveryDate\u0026#34;: planetsData.bodies[7].discoveryDate, \u0026#34;meanRadius\u0026#34;: planetsData.bodies[7].meanRadius, \u0026#34;moons\u0026#34;: planetsData.bodies[7].moons, } } switch (followPlanet) { case \u0026#34;sun\u0026#34;: easycam.setState({ distance: 350, center: [0, 0, 0], rotation: [0.5, -0.15, 0.77, 0.3], }); break; case \u0026#34;mercury\u0026#34;: easycam.setState({ distance: 250, center: orbit1.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 200); break; case \u0026#34;venus\u0026#34;: easycam.setState({ distance: 250, center: orbit2.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 200); break; case \u0026#34;earth\u0026#34;: easycam.setState({ distance: 250, center: orbit3.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 200); break; case \u0026#34;mars\u0026#34;: easycam.setState({ distance: 250, center: orbit4.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 200); break; case \u0026#34;jupiter\u0026#34;: easycam.setState({ distance: 400, center: orbit5.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 200); break; case \u0026#34;saturn\u0026#34;: easycam.setState({ distance: 400, center: orbit6.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 100); break; case \u0026#34;uranus\u0026#34;: easycam.setState({ distance: 400, center: orbit7.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 100); break; case \u0026#34;neptune\u0026#34;: easycam.setState({ distance: 250, center: orbit8.obj[0].getPosition(), rotation: [0.5, -0.15, 0.77, 0.3], }, 100); break; default: easycam.setCenter([0,0,0]); break; } beginHUD(); image(stars, 0, 0); endHUD(); angleMode(DEGREES); ambientLight(60, 60, 60); pointLight(255, 255, 255, 0, 0, 0); push(); noStroke(); rotateZ(frameCount*0.6) texture(sun_texture); sphere(150); pop(); orbits.forEach( (o) =\u0026gt;{ o.draw() } ); } class Orbit { constructor(x, y, z, xr, yr, zr, ellipseWidth, ellipseHeight) { this.obj = []; this.currentRot = [x ? x : 0, y ? y : 0, z ? z : 0]; this.rot = [xr ? xr : 0, yr ? yr : 0, zr ? zr : 0]; this.ellipseWidth = ellipseWidth; this.ellipseHeight = ellipseHeight; } draw() { push(); rotateZ(this.currentRot[2]); rotateY(this.currentRot[1]); rotateX(this.currentRot[0]); noFill(); stroke(\u0026#34;white\u0026#34;); strokeWeight(0.4); ellipse(0, 0, this.ellipseWidth, this.ellipseHeight, 50); for (let i = 0; i \u0026lt; this.obj.length; i++) { let o = this.obj[i]; o.draw(); dotsData.push([o.id, o.getPosition(), this.get3DPos(o)]); } pop(); } get3DPos(o) { let [x, y, z] = o.getPosition(); let pos = createVector(x, y, z); pos = this.rotate2(pos, createVector(1, 0, 0), this.currentRot[0]); pos = this.rotate2(pos, createVector(0, 1, 0), this.currentRot[1]); pos = this.rotate2(pos, createVector(0, 0, 1), this.currentRot[2]); return pos; } //https://stackoverflow.com/questions/67458592/how-would-i-rotate-a-vector-in-3d-space-p5-js rotate2(vect, axis, angle) { // Make sure our axis is a unit vector axis = p5.Vector.normalize(axis); return p5.Vector.add( p5.Vector.mult(vect, cos(angle)), p5.Vector.add( p5.Vector.mult(p5.Vector.cross(axis, vect), sin(angle)), p5.Vector.mult( p5.Vector.mult(axis, p5.Vector.dot(axis, vect)), 1 - cos(angle) ) ) ); } } class Dot { constructor(angle, speed, factorX, factorY, texture, radius, name) { this.id = ++dotId; this.angle = angle; this.speed = speed; this.factorX = factorX; this.factorY = factorY; this.texture = texture; this.radius = radius; this.name = name; } draw() { this.angle += this.speed; this.x = (cos(this.angle) * this.factorX) / 2; this.y = (sin(this.angle) * this.factorY) / 2; push(); translate(this.x, this.y); noStroke(); texture(this.texture); rotateZ(frameCount) sphere(this.radius); fill(\u0026#34;white\u0026#34;) pop(); push(); var position = createVector(this.x, this.y, 0) translate(position); let picked = mousePicking({ size: this.radius*2, shape: Tree.CIRCLE }); fill(picked ? color(33,248,246): 255,255,255,10); if (picked){ if(this.name === \u0026#34;earth\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(earthData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(earthData.gravity, 510,750) text(\u0026#34;Mean radius:\u0026#34;, 400,800) text(earthData.meanRadius, 510,800) text(\u0026#34;Moons:\u0026#34;, 400,850) text(earthData.moons[0].moon, 510,850) endHUD() }else if(this.name === \u0026#34;mercur\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(mercurData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(mercurData.gravity, 510,750) text(\u0026#34;Mean Radius:\u0026#34;, 400,790) text(mercurData.meanRadius, 510,790) text(\u0026#34;Random fact:\u0026#34;, 400,840) text(\u0026#34;It is the smallest planet\u0026#34;, 400,870) text(\u0026#34;a littler bigger than moon\u0026#34;, 400,900) endHUD() }else if(this.name === \u0026#34;venus\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(venusData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(venusData.gravity, 510,750) text(\u0026#34;Mean Radius:\u0026#34;, 400,790) text(venusData.meanRadius, 510,790) text(\u0026#34;Random fact:\u0026#34;, 400,840) text(\u0026#34;It is the hotest planet\u0026#34;, 400,870) text(\u0026#34;with 470¬∞c\u0026#34;, 400,900) endHUD() }else if(this.name === \u0026#34;mars\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(marsData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(marsData.gravity, 510,750) text(\u0026#34;Mean Radius:\u0026#34;, 400,790) text(marsData.meanRadius, 510,790) text(\u0026#34;Random fact:\u0026#34;, 400,840) text(\u0026#34;Theoretically you can sow\u0026#34;, 400,870) text(\u0026#34;potatos due to minerals\u0026#34;, 400,900) endHUD() }else if(this.name === \u0026#34;jupiter\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(jupiterData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(jupiterData.gravity, 510,750) text(\u0026#34;Mean Radius:\u0026#34;, 400,790) text(jupiterData.meanRadius, 510,790) text(\u0026#34;Random fact:\u0026#34;, 400,840) text(\u0026#34;It is the fastest planet\u0026#34;, 400,870) text(\u0026#34;one day takes 10 hours.\u0026#34;, 400,900) endHUD() }else if(this.name === \u0026#34;saturn\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(saturnData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(saturnData.gravity, 510,750) text(\u0026#34;Mean Radius:\u0026#34;, 400,790) text(saturnData.meanRadius, 510,790) text(\u0026#34;Random fact:\u0026#34;, 400,840) text(\u0026#34;It is the fastest planet\u0026#34;, 400,870) text(\u0026#34;one day takes 10 hours.\u0026#34;, 400,900) endHUD() }else if(this.name === \u0026#34;uranus\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(uranusData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(uranusData.gravity, 510,750) text(\u0026#34;Mean Radius:\u0026#34;, 400,790) text(uranusData.meanRadius, 510,790) text(\u0026#34;Random fact:\u0026#34;, 400,840) text(\u0026#34;It rains diamons!!\u0026#34;, 400,870) text(\u0026#34;so sad that in earth\u0026#34;, 400,900) text(\u0026#34;rains water...\u0026#34;, 400,930) endHUD() }else if(this.name === \u0026#34;neptune\u0026#34;){ beginHUD() fill(color(255,255,255)) rect(355, 650, 300, 300, 50); textSize(37); text(neptureData.name, 400,700) textSize(17); text(\u0026#34;Gravity:\u0026#34;, 400,750) text(neptureData.gravity, 510,750) text(\u0026#34;Mean Radius:\u0026#34;, 400,790) text(neptureData.meanRadius, 510,790) text(\u0026#34;Random fact:\u0026#34;, 400,840) text(\u0026#34;One year takes 165 years\u0026#34;, 400,900) endHUD() } } noStroke(); strokeWeight(0); stroke(picked ? color(33,248,246): 255,255,255,50); bullsEye({ size: this.radius*2, shape: Tree.CIRCLE }); pop(); } getPosition() { return [this.x, this.y, 0]; } } class Ring { constructor(diameter, angle, speed, factorX, factorY, texture) { this.id = ++dotId; this.diameter = diameter; this.angle = angle; this.speed = speed; this.factorX = factorX; this.factorY = factorY; this.texture = texture; // } draw() { this.angle += this.speed; this.x = (cos(this.angle) * this.factorX) / 2; this.y = (sin(this.angle) * this.factorY) / 2; push(); noStroke(); texture(this.texture); circle(this.x, this.y, this.diameter); pop(); } getPosition() { return [this.x, this.y, 0]; } } function travelPlanet(e) { followPlanet = e.target.value; var p = planetInfo(); p.draw(); } class planetInfo { draw(){ rect(-20,-20, 50, 50) } } Referencias # API planets info Orbitas del sistema solar Qu√© hace posible la vida en la tierra TreeGL library Textures Interpolaci√≥n Catmull-Rom Datos b√°sicos sistema solar "},{"id":2,"href":"/VisualComputing/docs/workshops/visual_masking/","title":"Visual Masking","section":"Docs","content":" Visual Masking # Es un fen√≥meno de la percepci√≥n visual. Ocurre cuando las visibilidad de la imagen, llamada objetivo es reducida por la presencia de otra imagen, llamada m√°scara.\nEl objetivo puede ser invisible o parecer que tiene un contraste o una luminosidad reducidos. Existen tres disposiciones temporales diferentes para el enmascaramiento: el fordward masking, el backward masking y el simultaneous masking. En el fordward masking, la m√°scara precede al objetivo. En fordward masking, la m√°scara sigue al objetivo. En el simultaneous masking, la m√°scara y el objetivo aparecen juntos. Existen dos disposiciones espaciales diferentes para el enmascaramiento: el enmascaramiento de patr√≥n y el metacontraste. El enmascaramiento de patr√≥n se produce cuando las ubicaciones del objetivo y de la m√°scara se superponen. El enmascaramiento de metacontraste se produce cuando la m√°scara no se solapa con la ubicaci√≥n del objetivo.\nImage kernels # A continuaci√≥n, presentamos la implementaci√≥n de algunos Kernels, o matrices de convoluci√≥n, que es un tipo de visual masking\nEl paso de las diferentes matrices, que describimos a continuaci√≥n tienen diferentes efectos sobre la imagen, entonces podemos jugar un poco cambiando los efectos en el primer selector.\nLas matrices que usamos para los efectos son las siguientes:\nBlur = \\(\\begin{bmatrix} 0,0625 \u0026amp; 0,125 \u0026amp; 0,0625\\\\ 0,125 \u0026amp; 0,25 \u0026amp; 0,125 \\\\ 0,0625 \u0026amp; 0,125 \u0026amp; 0,0625 \\end{bmatrix}\\) Bottom Sobel = \\(\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix}\\) Emboss = \\(\\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 1 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix}\\) Left Sobel = \\(\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -1\\\\ 2 \u0026amp; 0 \u0026amp; -2 \\\\ 1 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix}\\) Outline = \\(\\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 8 \u0026amp; -1 \\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix}\\) Right Sobel = \\(\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 1\\\\ -2 \u0026amp; 0 \u0026amp; 2 \\\\ -1 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\) Sharpen = \\(\\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 5 \u0026amp; -1 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix}\\) Top Sobel = \\(\\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 0 \u0026amp; 0 \\\\ -1 \u0026amp; -2 \u0026amp; -1 \\end{bmatrix}\\) Tambi√©n, planteamos un transformaci√≥n de la imagen a una representaci√≥n de luminosidad por el c√°lculo de Lumma, que se puede calcular mediante la siguiente f√≥rmula:\n\\[Luma = 0.299 \\times r \u0026#43; 0.587 \\times g\u0026#43;0.114 \\times b\\] Consejo #1\nSi pasas el cursor sobre una parte de la imagen, podr√°s ver la convoluci√≥n aplicada a una peque√±a √°rea definida por un cuadro alrededor de la posici√≥n del cursor, para ver la convoluci√≥n en toda la imagen, puedes presionar la tecla a Consejo #2\nEn los valores de la matriz, puedes colocar los valores que tu quieras para revisar como quedar√≠a una convoluci√≥n usando el kernel de tu preferencia Image histogram # Un histograma de imagen es un tipo de histograma que act√∫a como una representaci√≥n gr√°fica de la distribuci√≥n del tono en una imagen digital y traza el n√∫mero de p√≠xeles para cada valor de tono. Observando el histograma de una imagen concreta, el espectador podr√° juzgar toda la distribuci√≥n del tono.\nLos histogramas de imagen est√°n presentes en muchos servicios modernos. Los fot√≥grafos pueden utilizarlos como ayuda para mostrar la distribuci√≥n de los tonos capturados, y si se han perdido detalles de la imagen por culpa de las altas luces o las sombras oscurecidas.\nA continuaci√≥n planteamos los histogramas correspondientes a cada canal de color en el modo de color RGB y para la luminosidad en los modos de color HSL y HSB:\nReferencias # Visual masking Kernel in image processing Different image kernel \u0026amp; convolutions Image histogram HSL and HSV Lightness "}]